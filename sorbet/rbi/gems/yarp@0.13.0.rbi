# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yarp` gem.
# Please instead update this file by running `bin/tapioca gem yarp`.

# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/lib/prism/visitor.rb.erb
# if you are looking to modify the template
#
# source://yarp/lib/prism.rb#3
module Prism
  class << self
    # Mirror the Prism.dump API by using the serialization API.
    def dump(*_arg0); end

    # Mirror the Prism.dump_file API by using the serialization API.
    def dump_file(_arg0); end

    # Mirror the Prism.lex API by using the serialization API.
    def lex(*_arg0); end

    # Returns an array of tokens that closely resembles that of the Ripper lexer.
    # The only difference is that since we don't keep track of lexer state in the
    # same way, it's going to always return the NONE state.
    #
    # source://prism/0.15.1lib/prism.rb#33
    def lex_compat(source, filepath = T.unsafe(nil)); end

    # Mirror the Prism.lex_file API by using the serialization API.
    def lex_file(_arg0); end

    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # source://prism/0.15.1lib/prism.rb#40
    def lex_ripper(source); end

    # Load the serialized AST using the source as a reference into a tree.
    #
    # source://prism/0.15.1lib/prism.rb#45
    def load(source, serialized); end

    # Mirror the Prism.parse API by using the serialization API.
    def parse(*_arg0); end

    # Mirror the Prism.parse_file API by using the serialization API. This uses
    # native strings instead of Ruby strings because it allows us to use mmap when
    # it is available.
    def parse_file(_arg0); end

    # Mirror the Prism.parse_lex API by using the serialization API.
    def parse_lex(*_arg0); end

    # Mirror the Prism.parse_lex_file API by using the serialization API.
    def parse_lex_file(_arg0); end
  end
end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#45
class Prism::AliasGlobalVariableNode < ::Prism::Node
  # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
  #
  # @return [AliasGlobalVariableNode] a new instance of AliasGlobalVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#56
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#64
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#69
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#79
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#74
  def compact_child_nodes; end

  # def copy: (**params) -> AliasGlobalVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#84
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#69
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#97
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#106
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#102
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#53
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#47
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#50
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#130
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#140
    def type; end
  end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#139
class Prism::AliasMethodNode < ::Prism::Node
  # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
  #
  # @return [AliasMethodNode] a new instance of AliasMethodNode
  #
  # source://prism/0.15.1lib/prism/node.rb#160
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#168
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#173
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#183
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#178
  def compact_child_nodes; end

  # def copy: (**params) -> AliasMethodNode
  #
  # source://prism/0.15.1lib/prism/node.rb#188
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#173
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#201
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#210
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#206
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#157
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#151
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#154
  def old_name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#234
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#244
    def type; end
  end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#233
class Prism::AlternationPatternNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#264
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#272
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#277
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#287
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#282
  def compact_child_nodes; end

  # def copy: (**params) -> AlternationPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#292
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#277
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#305
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#314
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#255
  def left; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#310
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#261
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#258
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#338
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#348
    def type; end
  end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#327
class Prism::AndNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AndNode] a new instance of AndNode
  #
  # source://prism/0.15.1lib/prism/node.rb#368
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#376
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#381
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#391
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#386
  def compact_child_nodes; end

  # def copy: (**params) -> AndNode
  #
  # source://prism/0.15.1lib/prism/node.rb#396
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#381
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#409
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#418
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#359
  def left; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#414
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#365
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#362
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#442
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#452
    def type; end
  end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#421
class Prism::ArgumentsNode < ::Prism::Node
  # def initialize: (arguments: Array[Node], location: Location) -> void
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#466
  def initialize(arguments, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#472
  def accept(visitor); end

  # attr_reader arguments: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#463
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#477
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#487
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#482
  def compact_child_nodes; end

  # def copy: (**params) -> ArgumentsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#492
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#477
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#503
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#507
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#527
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#537
    def type; end
  end
end

# Represents an array literal. This can be a regular array using brackets or
# a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#497
class Prism::ArrayNode < ::Prism::Node
  # def initialize: (elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # source://prism/0.15.1lib/prism/node.rb#558
  def initialize(elements, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#566
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#571
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#609
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#555
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#581
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#576
  def compact_child_nodes; end

  # def copy: (**params) -> ArrayNode
  #
  # source://prism/0.15.1lib/prism/node.rb#586
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#571
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#599
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#549
  def elements; end

  # source://prism/0.15.1lib/prism/node.rb#613
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#604
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#552
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#635
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#645
    def type; end
  end
end

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#606
class Prism::ArrayPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#686
  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#697
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#702
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#748
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#683
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#717
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#707
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#668
  def constant; end

  # def copy: (**params) -> ArrayPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#722
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#702
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#738
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#752
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#743
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#680
  def opening_loc; end

  # attr_reader posts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#677
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#671
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#674
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#787
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#797
    def type; end
  end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# source://yarp/lib/prism/node.rb#736
class Prism::AssocNode < ::Prism::Node
  # def initialize: (key: Node, value: Node?, operator_loc: Location?, location: Location) -> void
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # source://prism/0.15.1lib/prism/node.rb#817
  def initialize(key, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#825
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#830
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#843
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#835
  def compact_child_nodes; end

  # def copy: (**params) -> AssocNode
  #
  # source://prism/0.15.1lib/prism/node.rb#848
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#830
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#861
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#870
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader key: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#808
  def key; end

  # def operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#866
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#814
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#898
  def type; end

  # attr_reader value: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#811
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#908
    def type; end
  end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# source://yarp/lib/prism/node.rb#837
class Prism::AssocSplatNode < ::Prism::Node
  # def initialize: (value: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#925
  def initialize(value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#932
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#937
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#949
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#942
  def compact_child_nodes; end

  # def copy: (**params) -> AssocSplatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#954
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#937
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#966
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#975
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#971
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#922
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1001
  def type; end

  # attr_reader value: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#919
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1011
    def type; end
  end
end

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# source://yarp/lib/prism/node.rb#930
class Prism::BackReferenceReadNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1025
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1031
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1036
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1046
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1041
  def compact_child_nodes; end

  # def copy: (**params) -> BackReferenceReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1051
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1036
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1062
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1066
  def inspect(inspector = T.unsafe(nil)); end

  # source://prism/0.15.1lib/prism/node.rb#1022
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1086
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1096
    def type; end
  end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# source://yarp/lib/prism/visitor.rb#13
class Prism::BasicVisitor
  # source://prism/0.15.1lib/prism/visitor.rb#14
  def visit(node); end

  # source://prism/0.15.1lib/prism/visitor.rb#18
  def visit_all(nodes); end

  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#1001
class Prism::BeginNode < ::Prism::Node
  # def initialize: (begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1127
  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1138
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#1188
  def begin_keyword; end

  # attr_reader begin_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1109
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1147
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1162
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1152
  def compact_child_nodes; end

  # def copy: (**params) -> BeginNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1167
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1147
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1183
  def deconstruct_keys(keys); end

  # attr_reader else_clause: ElseNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1118
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#1193
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1124
  def end_keyword_loc; end

  # attr_reader ensure_clause: EnsureNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1121
  def ensure_clause; end

  # source://prism/0.15.1lib/prism/node.rb#1197
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader rescue_clause: RescueNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1115
  def rescue_clause; end

  # source://prism/0.15.1lib/prism/node.rb#1142
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1112
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1242
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1252
    def type; end
  end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#1145
class Prism::BlockArgumentNode < ::Prism::Node
  # def initialize: (expression: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1269
  def initialize(expression, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1276
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1281
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1293
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1286
  def compact_child_nodes; end

  # def copy: (**params) -> BlockArgumentNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1298
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1281
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1310
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#1263
  def expression; end

  # source://prism/0.15.1lib/prism/node.rb#1319
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#1315
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1266
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1345
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1355
    def type; end
  end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
#
# source://yarp/lib/prism/node.rb#1238
class Prism::BlockLocalVariableNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [BlockLocalVariableNode] a new instance of BlockLocalVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1369
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1375
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1380
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1390
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1385
  def compact_child_nodes; end

  # def copy: (**params) -> BlockLocalVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1395
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1380
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1406
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1410
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1366
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1430
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1440
    def type; end
  end
end

# Represents a block of ruby code.
#
# [1, 2, 3].each { |i| puts x }
#                ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#1313
class Prism::BlockNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], parameters: BlockParametersNode?, body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1466
  def initialize(locals, parameters, body, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1476
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#1457
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1481
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#1524
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1463
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1494
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1486
  def compact_child_nodes; end

  # def copy: (**params) -> BlockNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1499
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1481
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1514
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1528
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#1451
  def locals; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#1519
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1460
  def opening_loc; end

  # attr_reader parameters: BlockParametersNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1454
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1562
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1572
    def type; end
  end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# source://yarp/lib/prism/node.rb#1436
class Prism::BlockParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1593
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1601
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1606
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1616
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1611
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1621
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1606
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1634
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1643
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism/0.15.1lib/prism/node.rb#1584
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1587
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#1639
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1590
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1665
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1675
    def type; end
  end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#1532
class Prism::BlockParametersNode < ::Prism::Node
  # def initialize: (parameters: ParametersNode?, locals: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1702
  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1711
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1716
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#1758
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1699
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1729
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1721
  def compact_child_nodes; end

  # def copy: (**params) -> BlockParametersNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1734
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1716
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1748
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1762
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1693
  def locals; end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#1753
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1696
  def opening_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1690
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1790
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1800
    def type; end
  end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#1643
class Prism::BreakNode < ::Prism::Node
  # def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1817
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1824
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#1811
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1829
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1841
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1834
  def compact_child_nodes; end

  # def copy: (**params) -> BreakNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1846
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1829
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1858
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#1867
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#1863
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1814
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#1893
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#1903
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#1736
class Prism::CallAndWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallAndWriteNode] a new instance of CallAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1938
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#1951
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://yarp/lib/prism/node.rb#1750
  def arguments; end

  # def call_operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#1997
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1917
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1956
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp/lib/prism/node.rb#1852
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#1753
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1969
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1961
  def compact_child_nodes; end

  # def copy: (**params) -> CallAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#1974
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#1956
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#1992
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#2021
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2002
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#1920
  def message_loc; end

  # def opening: () -> String?
  #
  # source://yarp/lib/prism/node.rb#1847
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#1747
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2017
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#1932
  def operator_loc; end

  # attr_reader read_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#1926
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#1914
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2007
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2055
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#1935
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2012
  def variable_call?; end

  # attr_reader write_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#1929
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#1923
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2065
    def type; end
  end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#1937
class Prism::CallNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Node?, flags: Integer, name: String, location: Location) -> void
  #
  # @return [CallNode] a new instance of CallNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2118
  def initialize(receiver, call_operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2132
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#2103
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2109
  def block; end

  # def call_operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2180
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2094
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2137
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2195
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2106
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2151
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2142
  def compact_child_nodes; end

  # def copy: (**params) -> CallNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2156
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2137
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2175
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#2209
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2185
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2097
  def message_loc; end

  # attr_reader name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#2115
  def name; end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2190
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2100
  def opening_loc; end

  # attr_reader receiver: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2091
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2200
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2253
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2205
  def variable_call?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#2112
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2263
    def type; end
  end
end

# source://yarp/lib/prism/node.rb#14478
module Prism::CallNodeFlags; end

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2110
class Prism::CallOperatorWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, flags: Integer, read_name: String, write_name: String, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2301
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2315
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://yarp/lib/prism/node.rb#2124
  def arguments; end

  # def call_operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2362
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2277
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2320
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp/lib/prism/node.rb#2231
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#2127
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2333
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2325
  def compact_child_nodes; end

  # def copy: (**params) -> CallOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2338
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2320
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2357
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#2381
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2367
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2280
  def message_loc; end

  # def opening: () -> String?
  #
  # source://yarp/lib/prism/node.rb#2226
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#2121
  def opening_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2292
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2295
  def operator_loc; end

  # attr_reader read_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#2286
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2274
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2372
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2416
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#2298
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2377
  def variable_call?; end

  # attr_reader write_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#2289
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#2283
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2426
    def type; end
  end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2297
class Prism::CallOrWriteNode < ::Prism::Node
  # def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, flags: Integer, read_name: String, write_name: String, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallOrWriteNode] a new instance of CallOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2461
  def initialize(receiver, call_operator_loc, message_loc, flags, read_name, write_name, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2474
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://yarp/lib/prism/node.rb#2311
  def arguments; end

  # def call_operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2520
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2440
  def call_operator_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2479
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp/lib/prism/node.rb#2413
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#2314
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2492
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2484
  def compact_child_nodes; end

  # def copy: (**params) -> CallOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2497
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2479
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2515
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#2544
  def inspect(inspector = T.unsafe(nil)); end

  # def message: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2525
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2443
  def message_loc; end

  # def opening: () -> String?
  #
  # source://yarp/lib/prism/node.rb#2408
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp/lib/prism/node.rb#2308
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2540
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2455
  def operator_loc; end

  # attr_reader read_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#2449
  def read_name; end

  # attr_reader receiver: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2437
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2530
  def safe_navigation?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2578
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#2458
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#2535
  def variable_call?; end

  # attr_reader write_name: String
  #
  # source://prism/0.15.1lib/prism/node.rb#2452
  def write_name; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#2446
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2588
    def type; end
  end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2483
class Prism::CapturePatternNode < ::Prism::Node
  # def initialize: (value: Node, target: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2608
  def initialize(value, target, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2616
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2621
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2631
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2626
  def compact_child_nodes; end

  # def copy: (**params) -> CapturePatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2636
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2621
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2649
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#2658
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2654
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2605
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#2602
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2682
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#2599
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2692
    def type; end
  end
end

# Represents the use of a case statement.
#
# case true
# ^^^^^^^^^
# when false
# end
#
# source://yarp/lib/prism/node.rb#2579
class Prism::CaseNode < ::Prism::Node
  # def initialize: (predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2720
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2730
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2774
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2714
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2735
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2749
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2740
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2708
  def conditions; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#2711
  def consequent; end

  # def copy: (**params) -> CaseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2754
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2735
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2769
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2779
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2717
  def end_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#2783
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2705
  def predicate; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2817
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2827
    def type; end
  end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2702
class Prism::ClassNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2862
  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#2875
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2853
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2880
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2922
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2841
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2894
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2885
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#2844
  def constant_path; end

  # def copy: (**params) -> ClassNode
  #
  # source://prism/0.15.1lib/prism/node.rb#2899
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#2880
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#2917
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#2932
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2856
  def end_keyword_loc; end

  # def inheritance_operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#2927
  def inheritance_operator; end

  # attr_reader inheritance_operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#2847
  def inheritance_operator_loc; end

  # source://prism/0.15.1lib/prism/node.rb#2936
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#2838
  def locals; end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2859
  def name; end

  # attr_reader superclass: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#2850
  def superclass; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2974
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#2984
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2849
class Prism::ClassVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableAndWriteNode] a new instance of ClassVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3007
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3016
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3021
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3031
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3026
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3036
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3021
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3050
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3059
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#2995
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#2998
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#3055
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3001
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3083
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3004
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3093
    def type; end
  end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#2948
class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3119
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3129
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3134
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3144
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3139
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3149
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3134
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3164
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3168
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3104
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3107
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3116
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3110
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3193
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3113
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3203
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3048
class Prism::ClassVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableOrWriteNode] a new instance of ClassVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3226
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3235
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3240
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3250
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3245
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3255
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3240
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3269
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3278
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3214
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3217
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#3274
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3220
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3302
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3223
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3312
    def type; end
  end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#3147
class Prism::ClassVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3326
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3332
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3337
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3347
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3342
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3352
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3337
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3363
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3367
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3323
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3387
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3397
    def type; end
  end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
#
# source://yarp/lib/prism/node.rb#3222
class Prism::ClassVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ClassVariableTargetNode] a new instance of ClassVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3411
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3417
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3422
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3432
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3427
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3437
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3422
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3448
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3452
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3408
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3472
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3482
    def type; end
  end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3297
class Prism::ClassVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location?, location: Location) -> void
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3505
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3514
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3519
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3529
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3524
  def compact_child_nodes; end

  # def copy: (**params) -> ClassVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3534
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3519
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3548
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3557
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3493
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3496
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#3553
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#3502
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3581
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3499
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3591
    def type; end
  end
end

# This represents a comment that was encountered during parsing.
#
# source://yarp/lib/prism/parse_result.rb#145
class Prism::Comment
  # @return [Comment] a new instance of Comment
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#150
  def initialize(type, location); end

  # source://prism/0.15.1lib/prism/parse_result.rb#155
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/parse_result.rb#164
  def inspect; end

  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#148
  def location; end

  # Returns true if the comment happens on the same line as other code and false if the comment is by itself
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#160
  def trailing?; end

  # Returns the value of attribute type.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#148
  def type; end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3396
class Prism::ConstantAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantAndWriteNode] a new instance of ConstantAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3614
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3623
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3628
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3638
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3633
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3643
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3628
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3657
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3666
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3602
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3605
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#3662
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3608
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3690
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3611
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3700
    def type; end
  end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3495
class Prism::ConstantOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3726
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3736
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3741
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3751
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3746
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3756
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3741
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3771
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3775
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3711
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3714
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3723
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3717
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3800
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3720
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3810
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3595
class Prism::ConstantOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantOrWriteNode] a new instance of ConstantOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3833
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3842
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3847
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3857
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3852
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3862
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3847
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3876
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3885
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3821
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3824
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#3881
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3827
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#3909
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3830
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#3919
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3694
class Prism::ConstantPathAndWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathAndWriteNode] a new instance of ConstantPathAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3939
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#3947
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3952
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3962
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3957
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3967
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#3952
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#3980
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#3989
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#3985
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#3933
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#3930
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4013
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#3936
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4023
    def type; end
  end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3788
class Prism::ConstantPathNode < ::Prism::Node
  # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4043
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4051
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4037
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4056
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4069
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4061
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4074
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4056
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4087
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4092
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4040
  def delimiter_loc; end

  # source://prism/0.15.1lib/prism/node_ext.rb#83
  def full_name; end

  # source://prism/0.15.1lib/prism/node_ext.rb#70
  def full_name_parts; end

  # source://prism/0.15.1lib/prism/node.rb#4096
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#4034
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4124
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4134
    def type; end
  end
end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3889
class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4157
  def initialize(target, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4166
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4171
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4181
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4176
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4186
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4171
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4200
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#4204
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4154
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4148
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4145
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4229
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4151
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4239
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#3984
class Prism::ConstantPathOrWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathOrWriteNode] a new instance of ConstantPathOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4259
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4267
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4272
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4282
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4277
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4287
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4272
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4300
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#4309
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4305
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4253
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4250
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4333
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4256
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4343
    def type; end
  end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#4078
class Prism::ConstantPathTargetNode < ::Prism::Node
  # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
  #
  # @return [ConstantPathTargetNode] a new instance of ConstantPathTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4363
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4371
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4357
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4376
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4389
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4381
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4394
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4376
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4407
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4412
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4360
  def delimiter_loc; end

  # source://prism/0.15.1lib/prism/node_ext.rb#95
  def full_name; end

  # source://prism/0.15.1lib/prism/node_ext.rb#90
  def full_name_parts; end

  # source://prism/0.15.1lib/prism/node.rb#4416
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader parent: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#4354
  def parent; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4444
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4454
    def type; end
  end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#4185
class Prism::ConstantPathWriteNode < ::Prism::Node
  # def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4480
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4488
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4493
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4503
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4498
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantPathWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4508
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4493
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4521
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#4530
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4526
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4474
  def operator_loc; end

  # attr_reader target: ConstantPathNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4471
  def target; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4554
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4477
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4564
    def type; end
  end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# source://yarp/lib/prism/node.rb#4279
class Prism::ConstantReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4578
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4584
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4589
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4599
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4594
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4604
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4589
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4615
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node_ext.rb#63
  def full_name; end

  # source://prism/0.15.1lib/prism/node_ext.rb#58
  def full_name_parts; end

  # source://prism/0.15.1lib/prism/node.rb#4619
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4575
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4639
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4649
    def type; end
  end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
#
# source://yarp/lib/prism/node.rb#4354
class Prism::ConstantTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [ConstantTargetNode] a new instance of ConstantTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4663
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4669
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4674
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4684
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4679
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4689
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4674
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4700
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#4704
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4660
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4724
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4734
    def type; end
  end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
# source://yarp/lib/prism/node.rb#4429
class Prism::ConstantWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [ConstantWriteNode] a new instance of ConstantWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4757
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4766
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4771
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4781
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4776
  def compact_child_nodes; end

  # def copy: (**params) -> ConstantWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4786
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4771
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4800
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#4809
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4745
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4748
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4805
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4754
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4833
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#4751
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#4843
    def type; end
  end
end

# This module is used for testing and debugging and is not meant to be used by
# consumers of this library.
#
# source://yarp/lib/prism/debug.rb#6
module Prism::Debug
  class << self
    # For the given source, compiles with CRuby and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://yarp/lib/prism/debug.rb#47
    def cruby_locals(source); end

    def memsize(_arg0); end
    def named_captures(_arg0); end

    # source://yarp/lib/prism/debug.rb#149
    def newlines(source); end

    # source://yarp/lib/prism/debug.rb#153
    def parse_serialize_file(filepath); end

    def parse_serialize_file_metadata(_arg0, _arg1); end

    # For the given source, parses with prism and returns a list of all of the
    # sets of local variables that were encountered.
    #
    # source://yarp/lib/prism/debug.rb#82
    def prism_locals(source); end

    def profile_file(_arg0); end
    def unescape_all(_arg0); end
    def unescape_minimal(_arg0); end
    def unescape_none(_arg0); end
    def unescape_whitespace(_arg0); end
  end
end

# source://yarp/lib/prism/debug.rb#7
class Prism::Debug::ISeq
  # @return [ISeq] a new instance of ISeq
  #
  # source://yarp/lib/prism/debug.rb#10
  def initialize(parts); end

  # source://yarp/lib/prism/debug.rb#26
  def each_child; end

  # source://yarp/lib/prism/debug.rb#22
  def instructions; end

  # source://yarp/lib/prism/debug.rb#18
  def local_table; end

  # Returns the value of attribute parts.
  #
  # source://yarp/lib/prism/debug.rb#8
  def parts; end

  # source://yarp/lib/prism/debug.rb#14
  def type; end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#4529
class Prism::DefNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, receiver: Node?, parameters: ParametersNode?, body: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [DefNode] a new instance of DefNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4891
  def initialize(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#4908
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#4867
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4913
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4927
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4918
  def compact_child_nodes; end

  # def copy: (**params) -> DefNode
  #
  # source://prism/0.15.1lib/prism/node.rb#4932
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#4913
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#4954
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#4959
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4873
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#4984
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#4888
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#4979
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#4885
  def equal_loc; end

  # source://prism/0.15.1lib/prism/node.rb#4988
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#4870
  def locals; end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#4969
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#4879
  def lparen_loc; end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#4855
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#4858
  def name_loc; end

  # def operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#4964
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#4876
  def operator_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#4864
  def parameters; end

  # attr_reader receiver: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#4861
  def receiver; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#4974
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#4882
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5034
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5044
    def type; end
  end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#4719
class Prism::DefinedNode < ::Prism::Node
  # def initialize: (lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location) -> void
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5067
  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5076
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5081
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5091
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5086
  def compact_child_nodes; end

  # def copy: (**params) -> DefinedNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5096
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5081
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5110
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#5129
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5125
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5064
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#5115
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#5055
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#5120
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#5061
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5153
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#5058
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5163
    def type; end
  end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#4828
class Prism::ElseNode < ::Prism::Node
  # def initialize: (else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5183
  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5191
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5196
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5208
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5201
  def compact_child_nodes; end

  # def copy: (**params) -> ElseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5213
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5196
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5226
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5231
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5174
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#5236
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#5180
  def end_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#5240
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#5177
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5267
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5277
    def type; end
  end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# source://yarp/lib/prism/node.rb#4932
class Prism::EmbeddedStatementsNode < ::Prism::Node
  # def initialize: (opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location) -> void
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5297
  def initialize(opening_loc, statements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5305
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5310
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5350
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5294
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5322
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5315
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedStatementsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5327
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5310
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5340
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#5354
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5345
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5288
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#5291
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5381
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5391
    def type; end
  end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# source://yarp/lib/prism/node.rb#5036
class Prism::EmbeddedVariableNode < ::Prism::Node
  # def initialize: (operator_loc: Location, variable: Node, location: Location) -> void
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5408
  def initialize(operator_loc, variable, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5415
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5420
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5430
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5425
  def compact_child_nodes; end

  # def copy: (**params) -> EmbeddedVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5435
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5420
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5447
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#5456
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5452
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5402
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5478
  def type; end

  # attr_reader variable: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#5405
  def variable; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5488
    def type; end
  end
end

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# source://yarp/lib/prism/node.rb#5127
class Prism::EnsureNode < ::Prism::Node
  # def initialize: (ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5512
  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5520
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5525
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5537
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5530
  def compact_child_nodes; end

  # def copy: (**params) -> EnsureNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5542
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5525
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5555
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5565
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5509
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5560
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5503
  def ensure_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#5569
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#5506
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5596
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5606
    def type; end
  end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#5231
class Prism::FalseNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5617
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5622
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5627
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5637
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5632
  def compact_child_nodes; end

  # def copy: (**params) -> FalseNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5642
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5627
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5652
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#5656
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5675
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5685
    def type; end
  end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#     ^^^^^^^^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#     ^^^^^^^^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#5306
class Prism::FindPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5720
  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5731
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5736
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#5782
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#5717
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5751
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5741
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#5702
  def constant; end

  # def copy: (**params) -> FindPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5756
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5736
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5772
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#5786
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#5705
  def left; end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#5777
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#5714
  def opening_loc; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5708
  def requireds; end

  # attr_reader right: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#5711
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5818
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5828
    def type; end
  end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#5433
class Prism::FlipFlopNode < ::Prism::Node
  # def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [FlipFlopNode] a new instance of FlipFlopNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5851
  def initialize(left, right, operator_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5860
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5865
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5878
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5870
  def compact_child_nodes; end

  # def copy: (**params) -> FlipFlopNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5883
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5865
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5897
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#5907
  def exclude_end?; end

  # source://prism/0.15.1lib/prism/node.rb#5911
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#5839
  def left; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#5902
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#5845
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#5842
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#5945
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#5848
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#5955
    def type; end
  end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# source://yarp/lib/prism/node.rb#5550
class Prism::FloatNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5966
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#5971
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5976
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#5986
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5981
  def compact_child_nodes; end

  # def copy: (**params) -> FloatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#5991
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#5976
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6001
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6005
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6024
  def type; end

  # Returns the value of the node as a Ruby Float.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#8
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6034
    def type; end
  end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#5619
class Prism::ForNode < ::Prism::Node
  # def initialize: (index: Node, collection: Node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [ForNode] a new instance of ForNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6066
  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6078
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6083
  def child_nodes; end

  # attr_reader collection: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6048
  def collection; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6097
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6088
  def compact_child_nodes; end

  # def copy: (**params) -> ForNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6102
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6083
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6119
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#6134
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#6060
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#6139
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6063
  def end_keyword_loc; end

  # def for_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#6124
  def for_keyword; end

  # attr_reader for_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6054
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#6129
  def in_keyword; end

  # attr_reader in_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6057
  def in_keyword_loc; end

  # attr_reader index: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6045
  def index; end

  # source://prism/0.15.1lib/prism/node.rb#6143
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#6051
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6176
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6186
    def type; end
  end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#       ^^^^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#5763
class Prism::ForwardingArgumentsNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6199
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6204
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6209
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6219
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6214
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingArgumentsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6224
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6209
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6234
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6238
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6257
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6267
    def type; end
  end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# source://yarp/lib/prism/node.rb#5833
class Prism::ForwardingParameterNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6279
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6284
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6289
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6299
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6294
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6304
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6289
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6314
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6318
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6337
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6347
    def type; end
  end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#5902
class Prism::ForwardingSuperNode < ::Prism::Node
  # def initialize: (block: BlockNode?, location: Location) -> void
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6361
  def initialize(block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6367
  def accept(visitor); end

  # attr_reader block: BlockNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#6358
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6372
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6384
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6377
  def compact_child_nodes; end

  # def copy: (**params) -> ForwardingSuperNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6389
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6372
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6400
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6404
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6429
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6439
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#5984
class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableAndWriteNode] a new instance of GlobalVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6462
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6471
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6476
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6486
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6481
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6491
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6476
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6505
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6514
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6450
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6453
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#6510
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6456
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6538
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6459
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6548
    def type; end
  end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6083
class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6574
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6584
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6589
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6599
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6594
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6604
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6589
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6619
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6623
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6559
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6562
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6571
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6565
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6648
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6568
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6658
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6183
class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableOrWriteNode] a new instance of GlobalVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6681
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6690
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6695
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6705
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6700
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6710
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6695
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6724
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6733
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6669
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6672
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#6729
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6675
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6757
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6678
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6767
    def type; end
  end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# source://yarp/lib/prism/node.rb#6282
class Prism::GlobalVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6781
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6787
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6792
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6802
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6797
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6807
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6792
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6818
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6822
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6778
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6842
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6852
    def type; end
  end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
#
# source://yarp/lib/prism/node.rb#6357
class Prism::GlobalVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableTargetNode] a new instance of GlobalVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6866
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6872
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6877
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6887
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6882
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6892
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6877
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6903
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#6907
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6863
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6927
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#6937
    def type; end
  end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6432
class Prism::GlobalVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6960
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#6969
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6974
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#6984
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6979
  def compact_child_nodes; end

  # def copy: (**params) -> GlobalVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#6989
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#6974
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7003
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#7012
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#6948
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6951
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#7008
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#6957
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7036
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#6954
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7046
    def type; end
  end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6531
class Prism::HashNode < ::Prism::Node
  # def initialize: (opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [HashNode] a new instance of HashNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7066
  def initialize(opening_loc, elements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7074
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7079
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#7117
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#7063
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7089
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7084
  def compact_child_nodes; end

  # def copy: (**params) -> HashNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7094
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7079
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7107
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7060
  def elements; end

  # source://prism/0.15.1lib/prism/node.rb#7121
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#7112
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#7057
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7143
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7153
    def type; end
  end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6631
class Prism::HashPatternNode < ::Prism::Node
  # def initialize: (constant: Node?, assocs: Array[Node], kwrest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7182
  def initialize(constant, assocs, kwrest, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7192
  def accept(visitor); end

  # attr_reader assocs: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7170
  def assocs; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7197
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#7241
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#7179
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7211
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7202
  def compact_child_nodes; end

  # attr_reader constant: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#7167
  def constant; end

  # def copy: (**params) -> HashPatternNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7216
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7197
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7231
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#7245
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader kwrest: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#7173
  def kwrest; end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#7236
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#7176
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7279
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7289
    def type; end
  end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#6757
class Prism::IfNode < ::Prism::Node
  # def initialize: (if_keyword_loc: Location?, predicate: Node, statements: StatementsNode?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [IfNode] a new instance of IfNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7318
  def initialize(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7328
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7337
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7351
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7342
  def compact_child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#7312
  def consequent; end

  # def copy: (**params) -> IfNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7356
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7337
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7371
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#7381
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#7315
  def end_keyword_loc; end

  # def if_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#7376
  def if_keyword; end

  # attr_reader if_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#7303
  def if_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#7385
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader predicate: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#7306
  def predicate; end

  # source://prism/0.15.1lib/prism/node.rb#7332
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#7309
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7420
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7430
    def type; end
  end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# source://yarp/lib/prism/node.rb#6885
class Prism::ImaginaryNode < ::Prism::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7444
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7450
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7455
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7465
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7460
  def compact_child_nodes; end

  # def copy: (**params) -> ImaginaryNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7470
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7455
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7481
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#7485
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#7441
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7506
  def type; end

  # Returns the value of the node as a Ruby Complex.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#15
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7516
    def type; end
  end
end

# Represents a node that is implicitly being added to the tree but doesn't
# correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
# source://yarp/lib/prism/node.rb#6965
class Prism::ImplicitNode < ::Prism::Node
  # def initialize: (value: Node, location: Location) -> void
  #
  # @return [ImplicitNode] a new instance of ImplicitNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7534
  def initialize(value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7540
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7545
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7555
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7550
  def compact_child_nodes; end

  # def copy: (**params) -> ImplicitNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7560
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7545
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7571
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#7575
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7596
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#7531
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7606
    def type; end
  end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7041
class Prism::InNode < ::Prism::Node
  # def initialize: (pattern: Node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location) -> void
  #
  # @return [InNode] a new instance of InNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7629
  def initialize(pattern, statements, in_loc, then_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#7638
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7643
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7656
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7648
  def compact_child_nodes; end

  # def copy: (**params) -> InNode
  #
  # source://prism/0.15.1lib/prism/node.rb#7661
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#7643
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#7675
  def deconstruct_keys(keys); end

  # def in: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#7680
  def in; end

  # attr_reader in_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#7623
  def in_loc; end

  # source://prism/0.15.1lib/prism/node.rb#7689
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader pattern: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#7617
  def pattern; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#7620
  def statements; end

  # def then: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#7685
  def then; end

  # attr_reader then_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#7626
  def then_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#7718
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#7728
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7153
class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableAndWriteNode] a new instance of InstanceVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8307
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8316
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8321
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8331
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8326
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8336
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8321
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8350
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8359
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8295
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8298
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#8355
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8301
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8383
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#8304
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8393
    def type; end
  end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7252
class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8419
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8429
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8434
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8444
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8439
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8449
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8434
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8464
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8468
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8404
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8407
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8416
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8410
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8493
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#8413
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8503
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7352
class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableOrWriteNode] a new instance of InstanceVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8526
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8535
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8540
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8550
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8545
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8555
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8540
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8569
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8578
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8514
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8517
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#8574
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8520
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8602
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#8523
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8612
    def type; end
  end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# source://yarp/lib/prism/node.rb#7451
class Prism::InstanceVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8626
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8632
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8637
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8647
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8642
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8652
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8637
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8663
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8667
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8623
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8687
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8697
    def type; end
  end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
#
# source://yarp/lib/prism/node.rb#7526
class Prism::InstanceVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableTargetNode] a new instance of InstanceVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8711
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8717
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8722
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8732
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8727
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8737
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8722
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8748
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8752
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8708
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8772
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8782
    def type; end
  end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7601
class Prism::InstanceVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8805
  def initialize(name, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8814
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8819
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8829
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8824
  def compact_child_nodes; end

  # def copy: (**params) -> InstanceVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8834
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8819
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8848
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#8857
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8793
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8796
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#8853
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#8802
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8881
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#8799
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8891
    def type; end
  end
end

# source://yarp/lib/prism/node.rb#14486
module Prism::IntegerBaseFlags; end

# Represents an integer number literal.
#
#     1
#     ^
#
# source://yarp/lib/prism/node.rb#7700
class Prism::IntegerNode < ::Prism::Node
  # def initialize: (flags: Integer, location: Location) -> void
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8905
  def initialize(flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#8911
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#8947
  def binary?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8916
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8926
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8921
  def compact_child_nodes; end

  # def copy: (**params) -> IntegerNode
  #
  # source://prism/0.15.1lib/prism/node.rb#8931
  def copy(**params); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#8957
  def decimal?; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#8916
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#8942
  def deconstruct_keys(keys); end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#8962
  def hexadecimal?; end

  # source://prism/0.15.1lib/prism/node.rb#8966
  def inspect(inspector = T.unsafe(nil)); end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#8952
  def octal?; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#8987
  def type; end

  # Returns the value of the node as a Ruby Integer.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#22
  def value; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#8902
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#8997
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation that
# is being used in the predicate of a conditional to implicitly match
# against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7798
class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [InterpolatedMatchLastLineNode] a new instance of InterpolatedMatchLastLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9022
  def initialize(opening_loc, parts, closing_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9031
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9110
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9041
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9080
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9016
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9051
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9046
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedMatchLastLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9056
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9041
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9070
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9105
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9090
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9085
  def ignore_case?; end

  # source://prism/0.15.1lib/prism/node.rb#9124
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9095
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9100
  def once?; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9075
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9010
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9013
  def parts; end

  # source://prism/0.15.1lib/prism/node.rb#9035
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9148
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9120
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9115
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#9019
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9158
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#7947
class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9181
  def initialize(opening_loc, parts, closing_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9190
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9269
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9200
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9239
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9175
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9210
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9205
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedRegularExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9215
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9200
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9229
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9264
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9249
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9244
  def ignore_case?; end

  # source://prism/0.15.1lib/prism/node.rb#9283
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9254
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9259
  def once?; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9234
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9169
  def opening_loc; end

  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#30
  def options; end

  # attr_reader parts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9172
  def parts; end

  # source://prism/0.15.1lib/prism/node.rb#9194
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9307
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9279
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#9274
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#9178
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9317
    def type; end
  end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8096
class Prism::InterpolatedStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9337
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9345
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9355
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#9393
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#9334
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9365
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9360
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9370
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9355
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9383
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#9397
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#9388
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#9328
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9331
  def parts; end

  # source://prism/0.15.1lib/prism/node.rb#9349
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9419
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9429
    def type; end
  end
end

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8198
class Prism::InterpolatedSymbolNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9449
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9457
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9467
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#9505
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#9446
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9477
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9472
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedSymbolNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9482
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9467
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9495
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#9509
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#9500
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#9440
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9443
  def parts; end

  # source://prism/0.15.1lib/prism/node.rb#9461
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9531
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9541
    def type; end
  end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8300
class Prism::InterpolatedXStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9561
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9569
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9579
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9617
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9558
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9589
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9584
  def compact_child_nodes; end

  # def copy: (**params) -> InterpolatedXStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9594
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9579
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9607
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#9621
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9612
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9552
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9555
  def parts; end

  # source://prism/0.15.1lib/prism/node.rb#9573
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9643
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9653
    def type; end
  end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# source://yarp/lib/prism/node.rb#8402
class Prism::KeywordHashNode < ::Prism::Node
  # def initialize: (elements: Array[Node], location: Location) -> void
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9667
  def initialize(elements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9673
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9678
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9688
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9683
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordHashNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9693
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9678
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9704
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9664
  def elements; end

  # source://prism/0.15.1lib/prism/node.rb#9708
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9728
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9738
    def type; end
  end
end

# Represents a keyword parameter to a method, block, or lambda definition.
#
#     def a(b:)
#           ^^
#     end
#
#     def a(b: 1)
#           ^^^^
#     end
#
# source://yarp/lib/prism/node.rb#8482
class Prism::KeywordParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, value: Node?, location: Location) -> void
  #
  # @return [KeywordParameterNode] a new instance of KeywordParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9763
  def initialize(name, name_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9771
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9776
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9788
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9781
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9793
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9776
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9806
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#9810
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9754
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9757
  def name_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9837
  def type; end

  # attr_reader value: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#9760
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9847
    def type; end
  end
end

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# source://yarp/lib/prism/node.rb#8577
class Prism::KeywordRestParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9868
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9876
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9881
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9891
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9886
  def compact_child_nodes; end

  # def copy: (**params) -> KeywordRestParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9896
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9881
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#9909
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#9918
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism/0.15.1lib/prism/node.rb#9859
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#9862
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#9914
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9865
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#9940
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#9950
    def type; end
  end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8669
class Prism::LambdaNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode?, body: Node?, location: Location) -> void
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # source://prism/0.15.1lib/prism/node.rb#9979
  def initialize(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#9990
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#9976
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9995
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10044
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9970
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10008
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10000
  def compact_child_nodes; end

  # def copy: (**params) -> LambdaNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10013
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#9995
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10029
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#10048
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#9961
  def locals; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10039
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9967
  def opening_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10034
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#9964
  def operator_loc; end

  # attr_reader parameters: BlockParametersNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#9973
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10083
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10093
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8802
class Prism::LocalVariableAndWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableAndWriteNode] a new instance of LocalVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10119
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10129
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10134
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10144
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10139
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableAndWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10149
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10134
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10164
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10116
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10173
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10113
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10104
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10169
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10107
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10198
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10110
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10208
    def type; end
  end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#8907
class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10237
  def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10248
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10253
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10263
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10258
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOperatorWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10268
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10253
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10284
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10234
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10288
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10228
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10219
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10231
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10222
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10314
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10225
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10324
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#9013
class Prism::LocalVariableOrWriteNode < ::Prism::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableOrWriteNode] a new instance of LocalVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10350
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10360
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10365
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10375
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10370
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableOrWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10380
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10365
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10395
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10347
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10404
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10344
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10335
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10400
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10338
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10429
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10341
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10439
    def type; end
  end
end

# Represents reading a local variable. Note that this requires that a local
# variable of the same name has already been written to in the same scope,
# otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# source://yarp/lib/prism/node.rb#9120
class Prism::LocalVariableReadNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10458
  def initialize(name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10465
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10470
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10480
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10475
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10485
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10470
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10497
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10455
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10501
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10452
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10522
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10532
    def type; end
  end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
#
# source://yarp/lib/prism/node.rb#9201
class Prism::LocalVariableTargetNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableTargetNode] a new instance of LocalVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10549
  def initialize(name, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10556
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10561
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10571
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10566
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10576
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10561
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10588
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10546
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10592
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10543
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10613
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10623
    def type; end
  end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# source://yarp/lib/prism/node.rb#9282
class Prism::LocalVariableWriteNode < ::Prism::Node
  # def initialize: (name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10649
  def initialize(name, depth, name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10659
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10664
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10674
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10669
  def compact_child_nodes; end

  # def copy: (**params) -> LocalVariableWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10679
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10664
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10694
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#10637
  def depth; end

  # source://prism/0.15.1lib/prism/node.rb#10703
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10634
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10640
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10699
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10646
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10728
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10643
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10738
    def type; end
  end
end

# This represents a location in the source.
#
# source://yarp/lib/prism/parse_result.rb#41
class Prism::Location
  # @return [Location] a new instance of Location
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#56
  def initialize(source, start_offset, length); end

  # source://prism/0.15.1lib/prism/parse_result.rb#123
  def ==(other); end

  # The list of comments attached to this location
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#54
  def comments; end

  # Create a new location object with the given options.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#64
  def copy(**options); end

  # source://prism/0.15.1lib/prism/parse_result.rb#115
  def deconstruct_keys(keys); end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#111
  def end_column; end

  # The line number where this location ends.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#99
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#83
  def end_offset; end

  # Returns a string representation of this location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#73
  def inspect; end

  # Returns a new location that stretches from this location to the given
  # other location. Raises an error if this location is not before the other
  # location or if they don't share the same source.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#132
  def join(other); end

  # The length of this location in bytes.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#51
  def length; end

  # source://prism/0.15.1lib/prism/parse_result.rb#119
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#78
  def slice; end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#105
  def start_column; end

  # The line number where this location starts.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#88
  def start_line; end

  # The content of the line where this location starts before this location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#93
  def start_line_slice; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#48
  def start_offset; end

  protected

  # Returns the value of attribute source.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#44
  def source; end

  class << self
    # source://prism/0.15.1lib/prism/parse_result.rb#139
    def null; end
  end
end

# source://yarp/lib/prism/node.rb#14500
module Prism::LoopFlags; end

# Represents a regular expression literal used in the predicate of a
# conditional to implicitly match against the last line read by an IO
# object.
#
#     if /foo/i then end
#        ^^^^^^
#
# source://yarp/lib/prism/node.rb#9389
class Prism::MatchLastLineNode < ::Prism::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
  #
  # @return [MatchLastLineNode] a new instance of MatchLastLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10766
  def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10776
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10856
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10781
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10826
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10757
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10791
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10786
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10821
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10754
  def content_loc; end

  # def copy: (**params) -> MatchLastLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10796
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10781
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10811
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10851
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10836
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10831
  def ignore_case?; end

  # source://prism/0.15.1lib/prism/node.rb#10870
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10841
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10846
  def once?; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10816
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10751
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10895
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism/0.15.1lib/prism/node.rb#10760
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10866
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#10861
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#10763
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#10905
    def type; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#9544
class Prism::MatchPredicateNode < ::Prism::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10925
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#10933
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10938
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10948
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10943
  def compact_child_nodes; end

  # def copy: (**params) -> MatchPredicateNode
  #
  # source://prism/0.15.1lib/prism/node.rb#10953
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#10938
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#10966
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#10975
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#10971
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#10922
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10919
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#10999
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#10916
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11009
    def type; end
  end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#9638
class Prism::MatchRequiredNode < ::Prism::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11029
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11037
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11042
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11052
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11047
  def compact_child_nodes; end

  # def copy: (**params) -> MatchRequiredNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11057
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11042
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11070
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11079
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11075
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11026
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#11023
  def pattern; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11103
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#11020
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11113
    def type; end
  end
end

# Represents writing local variables using a regular expression match with
# named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#9733
class Prism::MatchWriteNode < ::Prism::Node
  # def initialize: (call: CallNode, locals: Array[Symbol], location: Location) -> void
  #
  # @return [MatchWriteNode] a new instance of MatchWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11131
  def initialize(call, locals, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11138
  def accept(visitor); end

  # attr_reader call: CallNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11125
  def call; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11143
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11153
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11148
  def compact_child_nodes; end

  # def copy: (**params) -> MatchWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11158
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11143
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11170
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11174
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#11128
  def locals; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11196
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11206
    def type; end
  end
end

# Represents a node that is missing from the source and results in a syntax
# error.
#
# source://yarp/lib/prism/node.rb#9813
class Prism::MissingNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11215
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11220
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11225
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11235
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11230
  def compact_child_nodes; end

  # def copy: (**params) -> MissingNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11240
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11225
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11250
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11254
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11273
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11283
    def type; end
  end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#9882
class Prism::ModuleNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11312
  def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11323
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#11303
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11328
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11341
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11333
  def compact_child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#11300
  def constant_path; end

  # def copy: (**params) -> ModuleNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11346
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11328
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11362
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11372
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11306
  def end_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#11376
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#11294
  def locals; end

  # def module_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11367
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11297
  def module_keyword_loc; end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11309
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11407
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11417
    def type; end
  end
end

# Represents a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^
#
# source://yarp/lib/prism/node.rb#10006
class Prism::MultiTargetNode < ::Prism::Node
  # def initialize: (targets: Array[Node], lparen_loc: Location?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [MultiTargetNode] a new instance of MultiTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11437
  def initialize(targets, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11445
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11450
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11460
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11455
  def compact_child_nodes; end

  # def copy: (**params) -> MultiTargetNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11465
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11450
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11478
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11492
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#11483
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#11431
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#11488
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#11434
  def rparen_loc; end

  # attr_reader targets: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11428
  def targets; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11514
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11524
    def type; end
  end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#10103
class Prism::MultiWriteNode < ::Prism::Node
  # def initialize: (targets: Array[Node], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11550
  def initialize(targets, lparen_loc, rparen_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11560
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11565
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11575
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11570
  def compact_child_nodes; end

  # def copy: (**params) -> MultiWriteNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11580
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11565
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11595
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11614
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#11600
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#11538
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11610
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11544
  def operator_loc; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#11605
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#11541
  def rparen_loc; end

  # attr_reader targets: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11535
  def targets; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11639
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#11547
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11649
    def type; end
  end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# source://yarp/lib/prism/node.rb#10218
class Prism::NextNode < ::Prism::Node
  # def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
  #
  # @return [NextNode] a new instance of NextNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11666
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11673
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#11660
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11678
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11690
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11683
  def compact_child_nodes; end

  # def copy: (**params) -> NextNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11695
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11678
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11707
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11716
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11712
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11663
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11742
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11752
    def type; end
  end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# source://yarp/lib/prism/node.rb#10311
class Prism::NilNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [NilNode] a new instance of NilNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11763
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11768
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11773
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11783
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11778
  def compact_child_nodes; end

  # def copy: (**params) -> NilNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11788
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11773
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11798
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11802
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11821
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11831
    def type; end
  end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#10381
class Prism::NoKeywordsParameterNode < ::Prism::Node
  # def initialize: (operator_loc: Location, keyword_loc: Location, location: Location) -> void
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11849
  def initialize(operator_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11856
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11861
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11871
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11866
  def compact_child_nodes; end

  # def copy: (**params) -> NoKeywordsParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11876
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11861
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11888
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11902
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11898
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11846
  def keyword_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#11893
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#11843
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#11923
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#11933
    def type; end
  end
end

# This represents a node in the tree. It is the parent class of all of the
# various node types.
#
# source://yarp/lib/prism/node.rb#11
class Prism::Node
  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/node.rb#12
  def location; end

  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#14
  def newline?; end

  # Similar to inspect, but respects the current level of indentation given by
  # the pretty print object.
  #
  # source://prism/0.15.1lib/prism/node.rb#33
  def pretty_print(q); end

  # source://prism/0.15.1lib/prism/node.rb#18
  def set_newline_flag(newline_marked); end

  # Slice the location of the node from the source.
  #
  # source://prism/0.15.1lib/prism/node.rb#27
  def slice; end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# source://yarp/lib/prism/node.rb#10472
class Prism::NumberedReferenceReadNode < ::Prism::Node
  # def initialize: (number: Integer, location: Location) -> void
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11947
  def initialize(number, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#11953
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11958
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11968
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11963
  def compact_child_nodes; end

  # def copy: (**params) -> NumberedReferenceReadNode
  #
  # source://prism/0.15.1lib/prism/node.rb#11973
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#11958
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#11984
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#11988
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader number: Integer
  #
  # source://prism/0.15.1lib/prism/node.rb#11944
  def number; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12008
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12018
    def type; end
  end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#10548
class Prism::OptionalParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12042
  def initialize(name, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12051
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12056
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12066
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12061
  def compact_child_nodes; end

  # def copy: (**params) -> OptionalParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12071
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12056
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12085
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12094
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12030
  def name; end

  # attr_reader name_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12033
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12090
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12036
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12118
  def type; end

  # attr_reader value: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#12039
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12128
    def type; end
  end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#10647
class Prism::OrNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [OrNode] a new instance of OrNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12148
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12156
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12161
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12171
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12166
  def compact_child_nodes; end

  # def copy: (**params) -> OrNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12176
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12161
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12189
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12198
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#12139
  def left; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12194
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12145
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#12142
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12222
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12232
    def type; end
  end
end

# source://yarp/lib/prism/pack.rb#4
module Prism::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#57
class Prism::Pack::Directive
  # @return [Directive] a new instance of Directive
  #
  # source://yarp/lib/prism/pack.rb#60
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # source://yarp/lib/prism/pack.rb#98
  def describe; end

  # Returns the value of attribute endian.
  #
  # source://yarp/lib/prism/pack.rb#58
  def endian; end

  # Returns the value of attribute length.
  #
  # source://yarp/lib/prism/pack.rb#58
  def length; end

  # Returns the value of attribute length_type.
  #
  # source://yarp/lib/prism/pack.rb#58
  def length_type; end

  # Returns the value of attribute signed.
  #
  # source://yarp/lib/prism/pack.rb#58
  def signed; end

  # Returns the value of attribute size.
  #
  # source://yarp/lib/prism/pack.rb#58
  def size; end

  # Returns the value of attribute source.
  #
  # source://yarp/lib/prism/pack.rb#58
  def source; end

  # Returns the value of attribute type.
  #
  # source://yarp/lib/prism/pack.rb#58
  def type; end

  # Returns the value of attribute variant.
  #
  # source://yarp/lib/prism/pack.rb#58
  def variant; end

  # Returns the value of attribute version.
  #
  # source://yarp/lib/prism/pack.rb#58
  def version; end
end

# source://yarp/lib/prism/pack.rb#72
Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp/lib/prism/pack.rb#80
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp/lib/prism/pack.rb#86
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#162
class Prism::Pack::Format
  # @return [Format] a new instance of Format
  #
  # source://yarp/lib/prism/pack.rb#165
  def initialize(directives, encoding); end

  # source://yarp/lib/prism/pack.rb#170
  def describe; end

  # Returns the value of attribute directives.
  #
  # source://yarp/lib/prism/pack.rb#163
  def directives; end

  # Returns the value of attribute encoding.
  #
  # source://yarp/lib/prism/pack.rb#163
  def encoding; end
end

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# source://yarp/lib/prism/pack.rb#54
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#10742
class Prism::ParametersNode < ::Prism::Node
  # def initialize: (requireds: Array[Node], optionals: Array[Node], rest: RestParameterNode?, posts: Array[Node], keywords: Array[Node], keyword_rest: Node?, block: BlockParameterNode?, location: Location) -> void
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12265
  def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12277
  def accept(visitor); end

  # attr_reader block: BlockParameterNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#12262
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12282
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12300
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12287
  def compact_child_nodes; end

  # def copy: (**params) -> ParametersNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12305
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12282
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12322
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12326
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader keyword_rest: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#12259
  def keyword_rest; end

  # attr_reader keywords: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12256
  def keywords; end

  # attr_reader optionals: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12247
  def optionals; end

  # attr_reader posts: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12253
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12244
  def requireds; end

  # attr_reader rest: RestParameterNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#12250
  def rest; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12367
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12377
    def type; end
  end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#10876
class Prism::ParenthesesNode < ::Prism::Node
  # def initialize: (body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12397
  def initialize(body, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12405
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#12388
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12414
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12454
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12394
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12426
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12419
  def compact_child_nodes; end

  # def copy: (**params) -> ParenthesesNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12431
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12414
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12444
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12458
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12449
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12391
  def opening_loc; end

  # source://prism/0.15.1lib/prism/node.rb#12409
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12485
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12495
    def type; end
  end
end

# This represents an error that was encountered during parsing.
#
# source://yarp/lib/prism/parse_result.rb#170
class Prism::ParseError
  # @return [ParseError] a new instance of ParseError
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#199
  def initialize(message, location); end

  # source://prism/0.15.1lib/prism/parse_result.rb#204
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/parse_result.rb#208
  def inspect; end

  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#197
  def location; end

  # Returns the value of attribute message.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#197
  def message; end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the AST, any comments that were encounters, and any errors that were
# encountered.
#
# source://yarp/lib/prism/parse_result.rb#208
class Prism::ParseResult
  # @return [ParseResult] a new instance of ParseResult
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#237
  def initialize(value, comments, magic_comments, errors, warnings, source); end

  # Attach the list of comments to their respective locations in the tree.
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#168
  def attach_comments!; end

  # Returns the value of attribute comments.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def comments; end

  # source://prism/0.15.1lib/prism/parse_result.rb#246
  def deconstruct_keys(keys); end

  # Returns the value of attribute errors.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def errors; end

  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#254
  def failure?; end

  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def magic_comments; end

  # Walk the tree and mark nodes that are on a new line.
  #
  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#56
  def mark_newlines!; end

  # Returns the value of attribute source.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def source; end

  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#250
  def success?; end

  # Returns the value of attribute value.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def value; end

  # Returns the value of attribute warnings.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#235
  def warnings; end
end

# When we've parsed the source, we have both the syntax tree and the list of
# comments that we found in the source. This class is responsible for
# walking the tree and finding the nearest location to attach each comment.
#
# It does this by first finding the nearest locations to each comment.
# Locations can either come from nodes directly or from location fields on
# nodes. For example, a `ClassNode` has an overall location encompassing the
# entire class, but it also has a location for the `class` keyword.
#
# Once the nearest locations are found, it determines which one to attach
# to. If it's a trailing comment (a comment on the same line as other source
# code), it will favor attaching to the nearest location that occurs before
# the comment. Otherwise it will favor attaching to the nearest location
# that is after the comment.
#
# source://yarp/lib/prism/parse_result/comments.rb#19
class Prism::ParseResult::Comments
  # @return [Comments] a new instance of Comments
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#75
  def initialize(parse_result); end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#79
  def attach!; end

  # Returns the value of attribute parse_result.
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#73
  def parse_result; end

  private

  # Responsible for finding the nearest targets to the given comment within
  # the context of the given encapsulating node.
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#98
  def nearest_targets(node, comment); end
end

# A target for attaching comments that is based on a location field on a
# node. For example, the `end` token of a ClassNode.
#
# source://yarp/lib/prism/parse_result/comments.rb#49
class Prism::ParseResult::Comments::LocationTarget
  # @return [LocationTarget] a new instance of LocationTarget
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#52
  def initialize(location); end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#68
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#64
  def encloses?(comment); end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#60
  def end_offset; end

  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#50
  def location; end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#56
  def start_offset; end
end

# A target for attaching comments that is based on a specific node's
# location.
#
# source://yarp/lib/prism/parse_result/comments.rb#22
class Prism::ParseResult::Comments::NodeTarget
  # @return [NodeTarget] a new instance of NodeTarget
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#25
  def initialize(node); end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#42
  def <<(comment); end

  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#37
  def encloses?(comment); end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#33
  def end_offset; end

  # Returns the value of attribute node.
  #
  # source://prism/0.15.1lib/prism/parse_result/comments.rb#23
  def node; end

  # source://prism/0.15.1lib/prism/parse_result/comments.rb#29
  def start_offset; end
end

# The :line tracepoint event gets fired whenever the Ruby VM encounters an
# expression on a new line. The types of expressions that can trigger this
# event are:
#
# * if statements
# * unless statements
# * nodes that are children of statements lists
#
# In order to keep track of the newlines, we have a list of offsets that
# come back from the parser. We assign these offsets to the first nodes that
# we find in the tree that are on those lines.
#
# Note that the logic in this file should be kept in sync with the Java
# MarkNewlinesVisitor, since that visitor is responsible for marking the
# newlines for JRuby/TruffleRuby.
#
# source://yarp/lib/prism/parse_result/newlines.rb#20
class Prism::ParseResult::Newlines < ::Prism::Visitor
  # @return [Newlines] a new instance of Newlines
  #
  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#21
  def initialize(newline_marked); end

  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#25
  def visit_block_node(node); end

  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#38
  def visit_if_node(node); end

  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#25
  def visit_lambda_node(node); end

  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#45
  def visit_statements_node(node); end

  # source://prism/0.15.1lib/prism/parse_result/newlines.rb#38
  def visit_unless_node(node); end
end

# This represents a warning that was encountered during parsing.
#
# source://yarp/lib/prism/parse_result.rb#188
class Prism::ParseWarning
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#217
  def initialize(message, location); end

  # source://prism/0.15.1lib/prism/parse_result.rb#222
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/parse_result.rb#226
  def inspect; end

  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#215
  def location; end

  # Returns the value of attribute message.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#215
  def message; end
end

# Represents the use of the `^` operator for pinning an expression in a
# pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# source://yarp/lib/prism/node.rb#10985
class Prism::PinnedExpressionNode < ::Prism::Node
  # def initialize: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> void
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12519
  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12528
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12533
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12543
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12538
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12548
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12533
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12562
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#12507
  def expression; end

  # source://prism/0.15.1lib/prism/node.rb#12581
  def inspect(inspector = T.unsafe(nil)); end

  # def lparen: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12572
  def lparen; end

  # attr_reader lparen_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12513
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12567
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12510
  def operator_loc; end

  # def rparen: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12577
  def rparen; end

  # attr_reader rparen_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12516
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12605
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12615
    def type; end
  end
end

# Represents the use of the `^` operator for pinning a variable in a pattern
# matching expression.
#
#     foo in ^bar
#            ^^^^
#
# source://yarp/lib/prism/node.rb#11095
class Prism::PinnedVariableNode < ::Prism::Node
  # def initialize: (variable: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12633
  def initialize(variable, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12640
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12645
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12655
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12650
  def compact_child_nodes; end

  # def copy: (**params) -> PinnedVariableNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12660
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12645
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12672
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12681
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12677
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12630
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12703
  def type; end

  # attr_reader variable: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#12627
  def variable; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12713
    def type; end
  end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#11182
class Prism::PostExecutionNode < ::Prism::Node
  # def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12736
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12745
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12750
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12796
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12733
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12762
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12755
  def compact_child_nodes; end

  # def copy: (**params) -> PostExecutionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12767
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12750
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12781
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12800
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12786
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12727
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12791
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12730
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#12724
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12828
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12838
    def type; end
  end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#11297
class Prism::PreExecutionNode < ::Prism::Node
  # def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12861
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12870
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12875
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12921
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12858
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12887
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12880
  def compact_child_nodes; end

  # def copy: (**params) -> PreExecutionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12892
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12875
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12906
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#12925
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12911
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12852
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#12916
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#12855
  def opening_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#12849
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#12953
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#12963
    def type; end
  end
end

# The top level node of any parse tree.
#
# source://yarp/lib/prism/node.rb#11409
class Prism::ProgramNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], statements: StatementsNode, location: Location) -> void
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12977
  def initialize(locals, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#12984
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12989
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#12999
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12994
  def compact_child_nodes; end

  # def copy: (**params) -> ProgramNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13004
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#12989
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13016
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#13020
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#12971
  def locals; end

  # attr_reader statements: StatementsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#12974
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13042
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13052
    def type; end
  end
end

# source://yarp/lib/prism/node.rb#14505
module Prism::RangeFlags; end

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#11494
class Prism::RangeNode < ::Prism::Node
  # def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13078
  def initialize(left, right, operator_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13087
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13092
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13105
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13097
  def compact_child_nodes; end

  # def copy: (**params) -> RangeNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13110
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13092
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13124
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13134
  def exclude_end?; end

  # source://prism/0.15.1lib/prism/node.rb#13138
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#13066
  def left; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13129
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13072
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#13069
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13172
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#13075
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13182
    def type; end
  end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# source://yarp/lib/prism/node.rb#11611
class Prism::RationalNode < ::Prism::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13196
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13202
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13207
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13217
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13212
  def compact_child_nodes; end

  # def copy: (**params) -> RationalNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13222
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13207
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13233
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#13237
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader numeric: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#13193
  def numeric; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13258
  def type; end

  # Returns the value of the node as a Ruby Rational.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#40
  def value; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13268
    def type; end
  end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# source://yarp/lib/prism/node.rb#11687
class Prism::RedoNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13279
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13284
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13289
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13299
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13294
  def compact_child_nodes; end

  # def copy: (**params) -> RedoNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13304
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13289
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13314
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#13318
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13337
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13347
    def type; end
  end
end

# source://yarp/lib/prism/node.rb#14510
module Prism::RegularExpressionFlags; end

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# source://yarp/lib/prism/node.rb#11756
class Prism::RegularExpressionNode < ::Prism::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13373
  def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13383
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13463
  def ascii_8bit?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13388
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13433
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13364
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13398
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13393
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13428
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13361
  def content_loc; end

  # def copy: (**params) -> RegularExpressionNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13403
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13388
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13418
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13458
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13443
  def extended?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13438
  def ignore_case?; end

  # source://prism/0.15.1lib/prism/node.rb#13477
  def inspect(inspector = T.unsafe(nil)); end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13448
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13453
  def once?; end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13423
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13358
  def opening_loc; end

  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # source://prism/0.15.1lib/prism/node_ext.rb#48
  def options; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13502
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism/0.15.1lib/prism/node.rb#13367
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13473
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#13468
  def windows_31j?; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#13370
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13512
    def type; end
  end
end

# Represents a destructured required parameter node.
#
#     def foo((bar, baz))
#             ^^^^^^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#11912
class Prism::RequiredDestructuredParameterNode < ::Prism::Node
  # def initialize: (parameters: Array[Node], opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [RequiredDestructuredParameterNode] a new instance of RequiredDestructuredParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13533
  def initialize(parameters, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13541
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13546
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13584
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13530
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13556
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13551
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredDestructuredParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13561
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13546
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13574
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#13588
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13579
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13527
  def opening_loc; end

  # attr_reader parameters: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13524
  def parameters; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13610
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13620
    def type; end
  end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# source://yarp/lib/prism/node.rb#12010
class Prism::RequiredParameterNode < ::Prism::Node
  # def initialize: (name: Symbol, location: Location) -> void
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13635
  def initialize(name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13641
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13646
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13656
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13651
  def compact_child_nodes; end

  # def copy: (**params) -> RequiredParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13661
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13646
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13672
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#13676
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13632
  def name; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13696
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13706
    def type; end
  end
end

# Represents an expression modified with a rescue.
#
#   foo rescue nil
#   ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12085
class Prism::RescueModifierNode < ::Prism::Node
  # def initialize: (expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location) -> void
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13726
  def initialize(expression, keyword_loc, rescue_expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13734
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13743
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13753
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13748
  def compact_child_nodes; end

  # def copy: (**params) -> RescueModifierNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13758
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13743
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13771
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#13717
  def expression; end

  # source://prism/0.15.1lib/prism/node.rb#13780
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13776
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13720
  def keyword_loc; end

  # attr_reader rescue_expression: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#13723
  def rescue_expression; end

  # source://prism/0.15.1lib/prism/node.rb#13738
  def set_newline_flag(newline_marked); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13804
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13814
    def type; end
  end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#     ^^^^^^
#       foo
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field.
# `ex` is in the `exception` field.
#
# source://yarp/lib/prism/node.rb#12189
class Prism::RescueNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, reference: Node?, statements: StatementsNode?, consequent: RescueNode?, location: Location) -> void
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13849
  def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13860
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13865
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13880
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13870
  def compact_child_nodes; end

  # attr_reader consequent: RescueNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#13846
  def consequent; end

  # def copy: (**params) -> RescueNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13885
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13865
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#13901
  def deconstruct_keys(keys); end

  # attr_reader exceptions: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13834
  def exceptions; end

  # source://prism/0.15.1lib/prism/node.rb#13915
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#13906
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13831
  def keyword_loc; end

  # def operator: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#13911
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#13837
  def operator_loc; end

  # attr_reader reference: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#13840
  def reference; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#13843
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#13955
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#13965
    def type; end
  end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# source://yarp/lib/prism/node.rb#12325
class Prism::RestParameterNode < ::Prism::Node
  # def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#13986
  def initialize(name, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#13994
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13999
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14009
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14004
  def compact_child_nodes; end

  # def copy: (**params) -> RestParameterNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14014
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#13999
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14027
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14036
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader name: Symbol?
  #
  # source://prism/0.15.1lib/prism/node.rb#13977
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#13980
  def name_loc; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14032
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#13983
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14058
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14068
    def type; end
  end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#12417
class Prism::RetryNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14079
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14084
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14089
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14099
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14094
  def compact_child_nodes; end

  # def copy: (**params) -> RetryNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14104
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14089
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14114
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14118
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14137
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14147
    def type; end
  end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12486
class Prism::ReturnNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, arguments: ArgumentsNode?, location: Location) -> void
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14164
  def initialize(keyword_loc, arguments, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14171
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#14161
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14176
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14188
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14181
  def compact_child_nodes; end

  # def copy: (**params) -> ReturnNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14193
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14176
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14205
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14214
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14210
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#14158
  def keyword_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14240
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14250
    def type; end
  end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# source://yarp/lib/prism/node.rb#12579
class Prism::SelfNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14261
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14266
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14271
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14281
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14276
  def compact_child_nodes; end

  # def copy: (**params) -> SelfNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14286
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14271
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14296
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14300
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14319
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14329
    def type; end
  end
end

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12648
class Prism::SingletonClassNode < ::Prism::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14358
  def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14369
  def accept(visitor); end

  # attr_reader body: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#14352
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14374
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14413
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#14343
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14387
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14379
  def compact_child_nodes; end

  # def copy: (**params) -> SingletonClassNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14392
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14374
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14408
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14423
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#14355
  def end_keyword_loc; end

  # attr_reader expression: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#14349
  def expression; end

  # source://prism/0.15.1lib/prism/node.rb#14427
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader locals: Array[Symbol]
  #
  # source://prism/0.15.1lib/prism/node.rb#14340
  def locals; end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14418
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#14346
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14458
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14468
    def type; end
  end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# source://yarp/lib/prism/parse_result.rb#7
class Prism::Source
  # @return [Source] a new instance of Source
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#10
  def initialize(source, offsets = T.unsafe(nil)); end

  # source://prism/0.15.1lib/prism/parse_result.rb#27
  def column(value); end

  # source://prism/0.15.1lib/prism/parse_result.rb#19
  def line(value); end

  # source://prism/0.15.1lib/prism/parse_result.rb#23
  def line_offset(value); end

  # Returns the value of attribute offsets.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#8
  def offsets; end

  # source://prism/0.15.1lib/prism/parse_result.rb#15
  def slice(offset, length); end

  # Returns the value of attribute source.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#8
  def source; end

  private

  # source://prism/0.15.1lib/prism/parse_result.rb#33
  def compute_offsets(code); end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12777
class Prism::SourceEncodingNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14479
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14484
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14489
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14499
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14494
  def compact_child_nodes; end

  # def copy: (**params) -> SourceEncodingNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14504
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14489
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14514
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14518
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14537
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14547
    def type; end
  end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12846
class Prism::SourceFileNode < ::Prism::Node
  # def initialize: (filepath: String, location: Location) -> void
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14561
  def initialize(filepath, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14567
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14572
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14582
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14577
  def compact_child_nodes; end

  # def copy: (**params) -> SourceFileNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14587
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14572
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14598
  def deconstruct_keys(keys); end

  # attr_reader filepath: String
  #
  # source://prism/0.15.1lib/prism/node.rb#14558
  def filepath; end

  # source://prism/0.15.1lib/prism/node.rb#14602
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14622
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14632
    def type; end
  end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# source://yarp/lib/prism/node.rb#12921
class Prism::SourceLineNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14643
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14648
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14653
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14663
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14658
  def compact_child_nodes; end

  # def copy: (**params) -> SourceLineNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14668
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14653
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14678
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14682
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14701
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14711
    def type; end
  end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# source://yarp/lib/prism/node.rb#12990
class Prism::SplatNode < ::Prism::Node
  # def initialize: (operator_loc: Location, expression: Node?, location: Location) -> void
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14728
  def initialize(operator_loc, expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14735
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14740
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14752
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14745
  def compact_child_nodes; end

  # def copy: (**params) -> SplatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14757
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14740
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14769
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#14725
  def expression; end

  # source://prism/0.15.1lib/prism/node.rb#14778
  def inspect(inspector = T.unsafe(nil)); end

  # def operator: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#14774
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#14722
  def operator_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14804
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14814
    def type; end
  end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13083
class Prism::StatementsNode < ::Prism::Node
  # def initialize: (body: Array[Node], location: Location) -> void
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14828
  def initialize(body, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14834
  def accept(visitor); end

  # attr_reader body: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14825
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14839
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14849
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14844
  def compact_child_nodes; end

  # def copy: (**params) -> StatementsNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14854
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14839
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14865
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14869
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14889
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14899
    def type; end
  end
end

# Represents the use of compile-time string concatenation.
#
#     "foo" "bar"
#     ^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13158
class Prism::StringConcatNode < ::Prism::Node
  # def initialize: (left: Node, right: Node, location: Location) -> void
  #
  # @return [StringConcatNode] a new instance of StringConcatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14916
  def initialize(left, right, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#14923
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14928
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14938
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14933
  def compact_child_nodes; end

  # def copy: (**params) -> StringConcatNode
  #
  # source://prism/0.15.1lib/prism/node.rb#14943
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#14928
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#14955
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#14959
  def inspect(inspector = T.unsafe(nil)); end

  # attr_reader left: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#14910
  def left; end

  # attr_reader right: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#14913
  def right; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#14982
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#14992
    def type; end
  end
end

# source://yarp/lib/prism/node.rb#14536
module Prism::StringFlags; end

# Represents a string literal, a string contained within a `%w` list, or
# plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# source://yarp/lib/prism/node.rb#13248
class Prism::StringNode < ::Prism::Node
  # def initialize: (flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [StringNode] a new instance of StringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15025
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15035
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15040
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15090
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15019
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15050
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15045
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15085
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15016
  def content_loc; end

  # def copy: (**params) -> StringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15055
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15040
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15070
  def deconstruct_keys(keys); end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#15075
  def frozen?; end

  # source://prism/0.15.1lib/prism/node.rb#15094
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15080
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15013
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15119
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism/0.15.1lib/prism/node.rb#15022
  def unescaped; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#15010
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15129
    def type; end
  end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13371
class Prism::SuperNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Node?, location: Location) -> void
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15158
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15168
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15149
  def arguments; end

  # attr_reader block: Node?
  #
  # source://prism/0.15.1lib/prism/node.rb#15155
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15173
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15186
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15178
  def compact_child_nodes; end

  # def copy: (**params) -> SuperNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15191
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15173
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15206
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15225
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15211
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15143
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15216
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15146
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15221
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15152
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15259
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15269
    def type; end
  end
end

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# source://yarp/lib/prism/node.rb#13501
class Prism::SymbolNode < ::Prism::Node
  # def initialize: (opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15295
  def initialize(opening_loc, value_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15304
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15309
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15353
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15289
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15319
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15314
  def compact_child_nodes; end

  # def copy: (**params) -> SymbolNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15324
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15309
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15338
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15357
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15343
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15283
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15380
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism/0.15.1lib/prism/node.rb#15292
  def unescaped; end

  # def value: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15348
  def value; end

  # attr_reader value_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15286
  def value_loc; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15390
    def type; end
  end
end

# This represents a token from the Ruby source.
#
# source://yarp/lib/prism/parse_result.rb#233
class Prism::Token
  # @return [Token] a new instance of Token
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#263
  def initialize(type, value, location); end

  # source://prism/0.15.1lib/prism/parse_result.rb#287
  def ==(other); end

  # source://prism/0.15.1lib/prism/parse_result.rb#269
  def deconstruct_keys(keys); end

  # Returns the value of attribute location.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#261
  def location; end

  # source://prism/0.15.1lib/prism/parse_result.rb#273
  def pretty_print(q); end

  # Returns the value of attribute type.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#261
  def type; end

  # Returns the value of attribute value.
  #
  # source://prism/0.15.1lib/prism/parse_result.rb#261
  def value; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# source://yarp/lib/prism/node.rb#13609
class Prism::TrueNode < ::Prism::Node
  # def initialize: (location: Location) -> void
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15401
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15406
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15411
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15421
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15416
  def compact_child_nodes; end

  # def copy: (**params) -> TrueNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15426
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15411
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15436
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15440
  def inspect(inspector = T.unsafe(nil)); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15459
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15469
    def type; end
  end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13678
class Prism::UndefNode < ::Prism::Node
  # def initialize: (names: Array[Node], keyword_loc: Location, location: Location) -> void
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15486
  def initialize(names, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15493
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15498
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15508
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15503
  def compact_child_nodes; end

  # def copy: (**params) -> UndefNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15513
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15498
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15525
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15534
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15530
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15483
  def keyword_loc; end

  # attr_reader names: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15480
  def names; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15555
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15565
    def type; end
  end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13767
class Prism::UnlessNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, predicate: Node, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15594
  def initialize(keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15604
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15613
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15627
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15618
  def compact_child_nodes; end

  # attr_reader consequent: ElseNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15588
  def consequent; end

  # def copy: (**params) -> UnlessNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15632
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15613
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15647
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15657
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15591
  def end_keyword_loc; end

  # source://prism/0.15.1lib/prism/node.rb#15661
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15652
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15579
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#15582
  def predicate; end

  # source://prism/0.15.1lib/prism/node.rb#15608
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15585
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15696
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15706
    def type; end
  end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#13898
class Prism::UntilNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15735
  def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15745
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#15802
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15754
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#15797
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15723
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15767
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15759
  def compact_child_nodes; end

  # def copy: (**params) -> UntilNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15772
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15754
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15787
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15806
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15792
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15720
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#15726
  def predicate; end

  # source://prism/0.15.1lib/prism/node.rb#15749
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15729
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15837
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#15732
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15847
    def type; end
  end
end

# A visitor is a class that provides a default implementation for every accept
# method defined on the nodes. This means it can walk a tree without the
# caller needing to define any special handling. This allows you to handle a
# subset of the tree, while still walking the whole tree.
#
# For example, to find all of the method calls that call the `foo` method, you
# could write:
#
#     class FooCalls < Prism::Visitor
#       def visit_call_node(node)
#         if node.name == "foo"
#           # Do something with the node
#         end
#
#         # Call super so that the visitor continues walking the tree
#         super
#       end
#     end
#
# source://yarp/lib/prism/visitor.rb#46
class Prism::Visitor < ::Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_call_or_write_node(node); end

  # Visit a CapturePatternNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_capture_pattern_node(node); end

  # Visit a CaseNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_implicit_node(node); end

  # Visit a InNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_in_node(node); end

  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_index_and_write_node(node); end

  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_index_operator_write_node(node); end

  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_index_or_write_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_keyword_hash_node(node); end

  # Visit a KeywordParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_keyword_parameter_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_regular_expression_node(node); end

  # Visit a RequiredDestructuredParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_required_destructured_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_self_node(node); end

  # Visit a SingletonClassNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_statements_node(node); end

  # Visit a StringConcatNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_string_concat_node(node); end

  # Visit a StringNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # source://prism/0.15.1lib/prism/visitor.rb#22
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
#
# source://yarp/lib/prism/node.rb#14028
class Prism::WhenNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, conditions: Array[Node], statements: StatementsNode?, location: Location) -> void
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15869
  def initialize(keyword_loc, conditions, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15877
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15882
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15895
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15887
  def compact_child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15863
  def conditions; end

  # def copy: (**params) -> WhenNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15900
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#15882
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#15913
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#15922
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#15918
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15860
  def keyword_loc; end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15866
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#15949
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#15959
    def type; end
  end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://yarp/lib/prism/node.rb#14131
class Prism::WhileNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # source://prism/0.15.1lib/prism/node.rb#15988
  def initialize(keyword_loc, closing_loc, predicate, statements, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#15998
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # source://prism/0.15.1lib/prism/node.rb#16055
  def begin_modifier?; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16007
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#16050
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#15976
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16020
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16012
  def compact_child_nodes; end

  # def copy: (**params) -> WhileNode
  #
  # source://prism/0.15.1lib/prism/node.rb#16025
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16007
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16040
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#16059
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#16045
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#15973
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://prism/0.15.1lib/prism/node.rb#15979
  def predicate; end

  # source://prism/0.15.1lib/prism/node.rb#16002
  def set_newline_flag(newline_marked); end

  # attr_reader statements: StatementsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#15982
  def statements; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#16090
  def type; end

  private

  # Returns the value of attribute flags.
  #
  # source://prism/0.15.1lib/prism/node.rb#15985
  def flags; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#16100
    def type; end
  end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# source://yarp/lib/prism/node.rb#14259
class Prism::XStringNode < ::Prism::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location) -> void
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#16123
  def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#16132
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16137
  def child_nodes; end

  # def closing: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#16181
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#16117
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16147
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16142
  def compact_child_nodes; end

  # def content: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#16176
  def content; end

  # attr_reader content_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#16114
  def content_loc; end

  # def copy: (**params) -> XStringNode
  #
  # source://prism/0.15.1lib/prism/node.rb#16152
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16137
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16166
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#16185
  def inspect(inspector = T.unsafe(nil)); end

  # def opening: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#16171
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#16111
  def opening_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#16208
  def type; end

  # attr_reader unescaped: String
  #
  # source://prism/0.15.1lib/prism/node.rb#16120
  def unescaped; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#16218
    def type; end
  end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# source://yarp/lib/prism/node.rb#14367
class Prism::YieldNode < ::Prism::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # source://prism/0.15.1lib/prism/node.rb#16241
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://prism/0.15.1lib/prism/node.rb#16250
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # source://prism/0.15.1lib/prism/node.rb#16235
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16255
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16267
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16260
  def compact_child_nodes; end

  # def copy: (**params) -> YieldNode
  #
  # source://prism/0.15.1lib/prism/node.rb#16272
  def copy(**params); end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://prism/0.15.1lib/prism/node.rb#16255
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://prism/0.15.1lib/prism/node.rb#16286
  def deconstruct_keys(keys); end

  # source://prism/0.15.1lib/prism/node.rb#16305
  def inspect(inspector = T.unsafe(nil)); end

  # def keyword: () -> String
  #
  # source://prism/0.15.1lib/prism/node.rb#16291
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://prism/0.15.1lib/prism/node.rb#16229
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#16296
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#16232
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://prism/0.15.1lib/prism/node.rb#16301
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://prism/0.15.1lib/prism/node.rb#16238
  def rparen_loc; end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # def type: () -> Symbol
  #
  # source://prism/0.15.1lib/prism/node.rb#16333
  def type; end

  class << self
    # source://prism/0.15.1lib/prism/node.rb#16343
    def type; end
  end
end

# source://yarp/lib/yarp.rb#4
YARP = Prism
